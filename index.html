<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script src="js/datguimin.js"></script>
        <script src="js/orbitControls.js"></script>
<!--         <script src="https://threejs.org/examples/js/utils/BufferGeometryUtils.js"></script> -->
		<script>
            const gui = new dat.GUI();//za laku promjenu parametara da si mozemo namistit zeljeni oblik
            const world={
                device:{
                    width:4,
                    height:6,
                    radius:0.5,
                    rotateX:0,
                    rotateY:2.66,
                    rotateZ:0,
                    extrusionSteps: 2,
                    extrusionDepth: 1,
                },
                deviceBottom:{
                    rotateX:-Math.PI/2,
                    rotateY:0,
                    rotateZ:2.66
                },
                frontLight:{
                    x:0,
                    y:1,
                    z:1
                },
                backLight:{
                    x:0,
                    y:-1,
                    z:-1
                },
                button:{
                    extrusionSteps: 2,
                    extrusionDepth: 0.01,
                    extrusionBevelThickness: 1,
                    extrusionBevelSize: 0.1,
                    extrusionBevelOffset: 0,
                    extrusionBevelSegments: 1
                }
            }

            function updateDeviceMesh()//poziv kod svake promjene nekog od dat.gui parametara
            {
                device.geometry.dispose();//makni je, ukloni kkao bi mogli rekreirat objekt nakon promjene u slideru
                deviceWidth=world.device.width;
                deviceHeight=world.device.height;
                deviceCornerRadius=world.device.radius;
                deviceShape=new THREE.Shape();
                generateDeviceShape();
                extrudeSettings.steps=world.device.extrusionSteps;
                extrudeSettings.depth=world.device.extrusionDepth;
                device.geometry = new THREE.ExtrudeGeometry( deviceShape, extrudeSettings );//ovo ce radit rerender jer se minja device objekt koji se dodaje uscenu a scena se rerendera u animation loop
                device.rotation.x = world.device.rotateX
                device.rotation.y = world.device.rotateY;
                device.rotation.z=world.device.rotateZ;
            }

            function updateDeviceBottomMesh()
            {
                deviceMiddleBottomPart.geometry.dispose();
                deviceWidth=world.device.width;
                deviceHeight=world.device.height;
                deviceCornerRadius=world.device.radius;
                deviceMiddleBottomShape=new THREE.Shape();
                generateDeviceMiddleBottomShape();
/*                 extrudeSettings.steps=world.device.extrusionSteps;
                extrudeSettings.depth=world.device.extrusionDepth; */
                deviceMiddleBottomPart.geometry = new THREE.ExtrudeGeometry( deviceMiddleBottomShape, deviceMiddleBottomExtrudeSettings );//ovo ce radit rerender jer se minja device objekt koji se dodaje uscenu a scena se rerendera u animation loop
                deviceMiddleBottomPart.rotation.x = world.deviceBottom.rotateX
                deviceMiddleBottomPart.rotation.y = world.deviceBottom.rotateY;
                deviceMiddleBottomPart.rotation.z=world.deviceBottom.rotateZ;
            }

            function generateDeviceLeftShape()
            {
                const deviceLeftShape=new THREE.Shape();

                deviceLeftShape.moveTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2);
                //specificiramo tocku srednju di se siku 2 linije povucene iz 2 tocke na krajevima i 1 od te 2 tocke(PRVA TOCKA JE TAMO DI SMO STALI SA LINETO ILI MOVETO)
                deviceLeftShape.quadraticCurveTo(-deviceWidth/2, -deviceHeight/2, -deviceWidth/2, -deviceHeight/2+deviceCornerRadius);//livi donji ugao
                deviceLeftShape.lineTo(-deviceWidth/2,deviceHeight/2-deviceCornerRadius);
                deviceLeftShape.quadraticCurveTo(-deviceWidth/2, deviceHeight/2, -deviceWidth/2+deviceCornerRadius, deviceHeight/2);//livi gornji ugao */
                deviceLeftShape.lineTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2);//spoji s pocetkon

                const deviceLeftGeometry = new THREE.ExtrudeGeometry( deviceLeftShape, deviceLeftRightMiddleTopExtrudeSettings );
                deviceLeftPart = new THREE.Mesh( deviceLeftGeometry, deviceMaterial );
                deviceLeftPart.rotation.y = 2.66-Math.PI;
                deviceLeftPart.rotation.z=-Math.PI/2;//ROTIRA GA ZA 90 OKO Z -> https://stackoverflow.com/questions/25626171/threejs-extrudegeometry-depth-gives-different-result-than-extrudepath
                scene.add( deviceLeftPart );
            }

            function generateDeviceRightShape()
            {
                const deviceRightShape= new THREE.Shape();

                deviceRightShape.moveTo(deviceWidth/2-deviceCornerRadius,-deviceHeight/2);
                deviceRightShape.quadraticCurveTo(deviceWidth/2, -deviceHeight/2, deviceWidth/2, -deviceHeight/2+deviceCornerRadius);//desni donji ugao
                deviceRightShape.lineTo(deviceWidth/2,deviceHeight/2-deviceCornerRadius);
                deviceRightShape.quadraticCurveTo(deviceWidth/2, deviceHeight/2, deviceWidth/2-deviceCornerRadius, deviceHeight/2);//desni gornji ugao
                deviceRightShape.lineTo(deviceWidth/2-deviceCornerRadius,-deviceHeight/2)//spoji s pocetkon
                
                const deviceRightGeometry= new THREE.ExtrudeGeometry( deviceRightShape, deviceLeftRightMiddleTopExtrudeSettings);
                deviceRightPart= new THREE.Mesh(deviceRightGeometry, deviceMaterial);
                deviceRightPart.rotation.y=2.66-Math.PI;
                deviceRightPart.rotation.z=-Math.PI/2;
                scene.add(deviceRightPart);
            }

            function generateDeviceMiddleTopShape()
            {
                const deviceMiddleTopShape = new THREE.Shape();

                //krenemo od dole kao i za left i right
                deviceMiddleTopShape.moveTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2+deviceMiddleBottomPartDepth);
                deviceMiddleTopShape.lineTo(deviceWidth/2-deviceCornerRadius, -deviceHeight/2+deviceMiddleBottomPartDepth);
                deviceMiddleTopShape.lineTo(deviceWidth/2-deviceCornerRadius, deviceHeight/2);
                deviceMiddleTopShape.lineTo(-deviceWidth/2+deviceCornerRadius, deviceHeight/2);
                deviceMiddleTopShape.lineTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2+deviceMiddleBottomPartDepth)//spoji s prvom

                const deviceMiddleTopGeometry = new THREE.ExtrudeGeometry( deviceMiddleTopShape, deviceLeftRightMiddleTopExtrudeSettings);
                deviceMiddleTopPart= new THREE.Mesh(deviceMiddleTopGeometry, deviceMaterial);
                deviceMiddleTopPart.rotation.y=2.66-Math.PI;
                deviceMiddleTopPart.rotation.z=-Math.PI/2;
                scene.add(deviceMiddleTopPart);
            }

            function generateDeviceMiddleBottomShape(scene)
            {
                const deviceMiddleBottomShape=new THREE.Shape();
                //donji dio uredaja za rupama za usb c port i on/off botun
                //nacrtamo pravokutnik dimenzija:
                //1)širine kao širina srednjeg dijela uredaja 
                //2) visine kao dubine extrudanja uredaja -> 1 trenutno
                //crtamo ga pocevsi od donjeg dijela middleTop shapea pa prema dole jer cemo ga kasnije zarotirat oko x za 90 stupnjeva
                //dubina extrudanja će biti deviceMiddleBottomPartDepth
                deviceMiddleBottomShape.moveTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2+deviceMiddleBottomPartDepth)
                deviceMiddleBottomShape.lineTo(deviceWidth/2-deviceCornerRadius, -deviceHeight/2+deviceMiddleBottomPartDepth)
                deviceMiddleBottomShape.lineTo(deviceWidth/2-deviceCornerRadius,-deviceHeight/2+deviceMiddleBottomPartDepth-1.1);//-1.1 dodajemo jer je uredaj bez prednje strane tolike debljine, nama ce ta visina nakon rotacije postat debljina, prednji dio će popunit ostatak a kod crtanja rupa u sredinu cemo morat racunat i debljinu prednjeg dijela
                deviceMiddleBottomShape.lineTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2+deviceMiddleBottomPartDepth-1.1)
                deviceMiddleBottomShape.lineTo(-deviceWidth/2+deviceCornerRadius, -deviceHeight/2+deviceMiddleBottomPartDepth);//spoji s pocetnim
                


                //dodaj rupe
                //rupa za cport
                //ima oblik trapeza, zadamo mjere za a i c stranice
                let cPortWidthC=0.083*deviceWidth,cPortWidthA=0.133*deviceWidth,cPortHeight=0.1;

                let cPortHole= new THREE.Path();

                //pocinjemo crtat od lijeve tocke donje stranice(c)
                //srediste trapeza je u sredini -> sredina donjeg dijela je gornja stranica - (gornja - donja stranica)/2, stavljamo minus jer smo na negativnom dijelu pa 'dodajemo' oduzimanjem  (-height/2+deviceMiddleBottomPartDepth) - [(-height/2+deviceMiddleBottomPartDepth) - (-height/2+deviceMiddleBottomPartDepth-1)]/2 = (-height/2+deviceMiddleBottomPartDepth) - 0.5
                //lijeva tocka će bit udaljena za pola sirine osnovice c od sredista
                //KRECEMO OD DONJE STRANICE, PENJEMO SE NA GORNJU VERTIKALNO(IMAJU ISTU SIRINU KAO OSNOVIA TRAPEZA A) I ONDA IDEMO NA C
                cPortHole.moveTo( -cPortWidthA/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - cPortHeight/2)//sredina trapeza ce bit di i sredina donjeg dijela -> spustimo se jos za pola visine za doc na donju stranicu
                cPortHole.lineTo(cPortWidthA/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - cPortHeight/2)//linija do desne tocke osnovice
                cPortHole.lineTo(cPortWidthA/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - cPortHeight/2+0.01*deviceHeight)//linija do desne tocke osnovice
                
                cPortHole.lineTo( cPortWidthC/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 + cPortHeight/2)//povezi s desnom tockom gornje stranice trapeza a, dizemo se za portHeight pprema gore
                cPortHole.lineTo( -cPortWidthC/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 + cPortHeight/2)//povezi s lijevom tockom gornje stranice trapeza a
                cPortHole.lineTo(-cPortWidthA/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - cPortHeight/2+0.01*deviceHeight)//linija do desne tocke osnovice
                cPortHole.lineTo(-cPortWidthA/2 , (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - cPortHeight/2)//povezi s pocetkom
                deviceMiddleBottomShape.holes.push(cPortHole);
                
                //rupa za on/off switch
                let switchHoleWidth=0.1*deviceHeight,switchHoleHeight=0.1*deviceHeight,distanceBetweenPortAndSwitch=0.066*deviceWidth;
                let switchHole=new THREE.Path();
                //ista logika kao za cPortHole samo sta nije trapez nego pravokutnik
                //krenemo od donje lijeve tocke
                //STAVLJAMO NEGATIVNE KOORDINATE JER CEMO KASNIJE ROTACIJOM OKO z zapravo doc na drugu stranu
                switchHole.moveTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - switchHoleHeight/2 )
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth), (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - switchHoleHeight/2)//donje desna
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth), (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 + switchHoleHeight/2)//gornji desni
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 + switchHoleHeight/2)//gornji lijevi
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-deviceHeight/2+deviceMiddleBottomPartDepth) - 0.55 - switchHoleHeight/2)//spoji sa pocetnim
                
                deviceMiddleBottomShape.holes.push(switchHole)

                //nacrtaj
                const deviceMiddleBottomGeometry= new THREE.ExtrudeGeometry( deviceMiddleBottomShape, deviceMiddleBottomExtrudeSettings);
                deviceMiddleBottomPart= new THREE.Mesh(deviceMiddleBottomGeometry, deviceMaterial);
                deviceMiddleBottomPart.rotation.x=-Math.PI/2;
                deviceMiddleBottomPart.rotation.z=2.66;
                deviceMiddleBottomPart.translateY(deviceHeight/2-deviceMiddleBottomPartDepth)//rotacija se odnosi realtivno u odnosu na gornji vrh shape di smo krenili crtat -> on se nalazi na ovoj udljenosti od sredista
                deviceMiddleBottomPart.translateZ(-deviceHeight/2)//udaljenost shapea kojeg smo nacrtali i iz kojeg smo extrudali oblik od sredista -> taj shape će nakon rotacije bit zapravo donja strana a njegova udaljenost od sredista po rotiranoj z osi je jednaka polovici visine uredaja
                scene.add(deviceMiddleBottomPart);

                //generiraj kose obrube koji vode prema rupi od switcha
                //svaki obrub je duzine/sirine(ovisno jel gornji/donji ili livi/desni) kao stranica obruba
                let switchDividerDepth=0.1,switchDividerBevelAngle=0.7;

                const switchDividerGeometry=new THREE.PlaneBufferGeometry(switchHoleWidth,switchDividerDepth);

                //GORNJI
                topSwitchDivider=new THREE.Mesh(switchDividerGeometry,switchDividersMaterial);
                topSwitchDivider.rotation.x=-Math.PI/2;
                topSwitchDivider.rotation.z=2.66-Math.PI;
                topSwitchDivider.translateZ(-deviceHeight/2+Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2));
                topSwitchDivider.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)
                topSwitchDivider.translateY(0.55-switchHoleHeight/2+Math.sin(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2))//0.55 je polovica ukupne dubine uredaja sa front i back side
                topSwitchDivider.rotateX(switchDividerBevelAngle)//nagni ga za kut
                scene.add(topSwitchDivider);

                //koristimo izgled gornjeg za sve ostale samo cemo ih translatirat/rotirat na pravo mjesto
                //DESNI
                rightSwitchDivider=new THREE.Mesh(switchDividerGeometry,switchDividersMaterial);
                rightSwitchDivider.rotation.x=-Math.PI/2;
                rightSwitchDivider.rotation.z=2.66-Math.PI;
                rightSwitchDivider.translateZ(-deviceHeight/2);
                rightSwitchDivider.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)
                rightSwitchDivider.translateY(0.55-switchHoleHeight/2)//0.55 je polovica ukupne dubine uredaja sa front i back side
                //leftSwitchDivider.rotateX(switchDividerBevelAngle)
                //rotiraj tako da bude uspravan
                rightSwitchDivider.rotateZ(Math.PI/2);
                rightSwitchDivider.translateX(switchHoleHeight/2);
                rightSwitchDivider.translateY(-switchHoleWidth/2+Math.sin(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2));
                rightSwitchDivider.translateZ(Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2));
                rightSwitchDivider.rotateX(switchDividerBevelAngle);
                scene.add(rightSwitchDivider);

                //LIJEVI
                leftSwitchDivider=new THREE.Mesh(switchDividerGeometry,switchDividersMaterial);
                leftSwitchDivider.rotation.x=-Math.PI/2;
                leftSwitchDivider.rotation.z=2.66-Math.PI;
                leftSwitchDivider.translateZ(-deviceHeight/2);
                leftSwitchDivider.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)
                leftSwitchDivider.translateY(0.55-switchHoleHeight/2)//0.55 je polovica ukupne dubine uredaja sa front i back side
                //leftSwitchDivider.rotateX(switchDividerBevelAngle)
                //rotiraj tako da bude uspravan
                leftSwitchDivider.rotateZ(Math.PI/2);
                leftSwitchDivider.translateX(switchHoleHeight/2);
                //OVDE GLEDAMO DIREKTNO TAJ KUT A ROTIRAMO ZA -Math.PI/2+BEVELANGLE
                leftSwitchDivider.translateY(switchHoleWidth/2-Math.sin(switchDividerBevelAngle)*(switchDividerDepth/2));
                leftSwitchDivider.translateZ(Math.cos(switchDividerBevelAngle)*(switchDividerDepth/2));
                leftSwitchDivider.rotateX(-Math.PI/2+switchDividerBevelAngle);
                scene.add(leftSwitchDivider);

                //DONJI
                bottomSwitchDivider=new THREE.Mesh(switchDividerGeometry,switchDividersMaterial);
                bottomSwitchDivider.rotation.x=-Math.PI/2;
                bottomSwitchDivider.rotation.z=2.66-Math.PI;
                bottomSwitchDivider.translateZ(-deviceHeight/2+Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2));
                bottomSwitchDivider.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)
                bottomSwitchDivider.translateY(0.55+switchHoleHeight/2-Math.sin(switchDividerBevelAngle)*(switchDividerDepth/2))//translatiraj na donji rub
                bottomSwitchDivider.rotateX(-switchDividerBevelAngle)//nagni ga za kut
                scene.add(bottomSwitchDivider);

                //dodaj ravninu za popunit prostor u sredini s rupon za switch
                //ravninu stavljamo na polovici bevela-> njhova sirina je sirina switch hole - 2* stranica koja se dobije preko sinusa kuta
                let offsetFromEdge=Math.sin(switchDividerBevelAngle)*(switchDividerDepth/2)
                let switchHoleMiddleShape=new THREE.Shape();
                switchHoleMiddleShape.moveTo(-switchHoleWidth/2+offsetFromEdge,switchHoleHeight/2-offsetFromEdge);//krecemo od gornjeg lijevog
                switchHoleMiddleShape.lineTo(switchHoleWidth/2-offsetFromEdge,switchHoleHeight/2-offsetFromEdge)
                switchHoleMiddleShape.lineTo(switchHoleWidth/2-offsetFromEdge,-switchHoleHeight/2+offsetFromEdge)
                switchHoleMiddleShape.lineTo(-switchHoleWidth/2+offsetFromEdge,-switchHoleHeight/2+offsetFromEdge)
                switchHoleMiddleShape.lineTo(-switchHoleWidth/2+offsetFromEdge,switchHoleHeight/2-offsetFromEdge);

                let switchHoleMiddleGeometry=new THREE.ShapeGeometry(switchHoleMiddleShape);
                let switchHoleMiddle=new THREE.Mesh(switchHoleMiddleGeometry,switchDividersMaterial);
                switchHoleMiddle.rotation.x=-Math.PI/2;
                switchHoleMiddle.rotation.z=2.66-Math.PI;
                switchHoleMiddle.translateZ(-deviceHeight/2+Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2));
                switchHoleMiddle.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2-0.005)//dovedi ga u srediste rupe, 0.005 radi korekcije male
                switchHoleMiddle.translateY(0.55)
                scene.add(switchHoleMiddle);

                //dodaj rupe(CRNA BOJA)
                let holeMaterial=new THREE.MeshPhongMaterial({//materijla za rupe je crna boja
                    color:0x000000,
                    side:THREE.DoubleSide
                });
                //1) RUPA DI CE BIT PREKIDAC
                let switchDarkHoleWidth=0.3*switchHoleWidth;//30% od sirine cijele rupe
                // podaci za on/off switch
                let switchOnOffWidth=0.05,switchOnOffHeight=0.05,switchOnOffDepth=0.075;
                const switchDarkHoleMiddleShape=new THREE.Shape();
                //visina je ista kao i sirina switcha
                switchDarkHoleMiddleShape.moveTo(-switchDarkHoleWidth/2,switchOnOffWidth/2);
                switchDarkHoleMiddleShape.lineTo(switchDarkHoleWidth/2,switchOnOffWidth/2);
                switchDarkHoleMiddleShape.lineTo(switchDarkHoleWidth/2,-switchOnOffWidth/2);
                switchDarkHoleMiddleShape.lineTo(-switchDarkHoleWidth/2,-switchOnOffWidth/2)
                switchDarkHoleMiddleShape.lineTo(-switchDarkHoleWidth/2,switchOnOffWidth/2);

                const switchDarkHoleMiddleGeometry=new THREE.ShapeGeometry(switchDarkHoleMiddleShape);
                const switchDarkHoleMiddle=new THREE.Mesh(switchDarkHoleMiddleGeometry,holeMaterial);
                //prebaci ga dole u sredinu
                switchDarkHoleMiddle.rotation.x=-Math.PI/2;
                switchDarkHoleMiddle.rotation.z=2.66-Math.PI;
                switchDarkHoleMiddle.translateZ(-deviceHeight/2+Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2)-0.001);
                switchDarkHoleMiddle.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)//dovedi ga u srediste rupe
                switchDarkHoleMiddle.translateY(0.55)
                scene.add(switchDarkHoleMiddle);



                //ON/OFF SWITCH
                const switchOnOffGeometry = new THREE.BoxGeometry( switchOnOffWidth,switchOnOffHeight,switchOnOffDepth );
                const switchOnOffMaterial = new THREE.MeshBasicMaterial( {color: 0xFF0000} );
                const switchOnOff = new THREE.Mesh( switchOnOffGeometry, switchOnOffMaterial );
                switchOnOff.rotation.x=-Math.PI/2;
                switchOnOff.rotation.z=2.66;
                switchOnOff.translateY(-(deviceMiddleBottomPartDepth+deviceExtrudeDepth)/2+0.1/2);
                switchOnOff.translateZ(-deviceHeight/2)
                switchOnOff.translateX(-(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2-switchDarkHoleWidth/2));//ukljuici uredaj-> pomakni ga na kraj rupe
                scene.add( switchOnOff );

                //2 RUPA ZA CPORT
                let cPortDarkHoleShape=new THREE.Shape();
                //pocinjemo crtat od lijeve tocke donje stranice(c)
                //srediste trapeza je u sredini -> sredina donjeg dijela je gornja stranica - (gornja - donja stranica)/2, stavljamo minus jer smo na negativnom dijelu pa 'dodajemo' oduzimanjem  (-height/2+deviceMiddleBottomPartDepth) - [(-height/2+deviceMiddleBottomPartDepth) - (-height/2+deviceMiddleBottomPartDepth-1)]/2 = (-height/2+deviceMiddleBottomPartDepth) - 0.5
                //lijeva tocka će bit udaljena za pola sirine osnovice c od sredista
                cPortDarkHoleShape.moveTo( -cPortWidthA/2 ,-cPortHeight/2)//sredina trapeza ce bit di i sredina donjeg dijela -> spustimo se jos za pola visine za doc na donju stranicu
                cPortDarkHoleShape.lineTo(cPortWidthA/2 , -cPortHeight/2)//linija do desne tocke osnovice
                cPortDarkHoleShape.lineTo(cPortWidthA/2,-cPortHeight/2+0.01*deviceHeight);
                cPortDarkHoleShape.lineTo(cPortWidthC/2,cPortHeight/2);
                cPortDarkHoleShape.lineTo( -cPortWidthC/2 ,cPortHeight/2)
                cPortDarkHoleShape.lineTo(-cPortWidthA/2 , -cPortHeight/2+0.01*deviceHeight)//PENJEMO SE VERTIKALNO NA STRANICU U IZNAD A
                cPortDarkHoleShape.lineTo( -cPortWidthA/2 ,-cPortHeight/2)//povezi s desnom tockom gornje stranice trapeza a, dizemo se za portHeight pprema gore
                
                const cPortDarkHoleGeometry=new THREE.ShapeGeometry(cPortDarkHoleShape);
                const cPortDarkHole=new THREE.Mesh(cPortDarkHoleGeometry,holeMaterial);
                cPortDarkHole.rotation.x=-Math.PI/2;
                cPortDarkHole.rotation.z=2.66;//zelimo zarotirat za 180 da dobijemo na drugu stranu
                cPortDarkHole.translateZ(-deviceHeight/2+Math.cos(Math.PI/2-switchDividerBevelAngle)*(switchDividerDepth/2)-0.001);//stavimo ih na istu visinu kao sto je i rupa za switch
                //cPortDarkHole.translateX(cPortWidthA/2+distanceBetweenPortAndSwitch+switchHoleWidth/2)//dovedi ga u srediste rupe
                cPortDarkHole.translateY(-0.55)
                scene.add(cPortDarkHole)
            }

            function generateButton(scene,bottomLeftX,bottomLeftY,width,height)
            {
                //napravi bazu botuna
                const buttonShape = new THREE.Shape();
                //ne idemo za cijeli width i height od rupe nego idemo do unutarnjih dijelova buttonFrame okvira -> udaljenost od rubova rupe je zapravo radijus buttonFramea
                buttonShape.moveTo( bottomLeftX+buttonFrameRadius,bottomLeftY+buttonFrameRadius);
                buttonShape.lineTo( bottomLeftX+buttonFrameRadius, bottomLeftY+height-buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+width-buttonFrameRadius, bottomLeftY+height-buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+width-buttonFrameRadius, bottomLeftY+buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+buttonFrameRadius, bottomLeftY+buttonFrameRadius );
                const buttonGeometry = new THREE.ExtrudeGeometry( buttonShape, buttonExtrudeSettings );
                const buttonMaterial = new THREE.MeshPhongMaterial( { color: 0x2F4F4F , side:THREE.FrontSide } );
                const button = new THREE.Mesh( buttonGeometry, buttonMaterial ) ;
                button.rotation.y = 2.66 - Math.PI;
                button.translateZ(frontDeviceShapeDepth+0.001)
                scene.add( button );

                //napravi okrugli dio na vrhu botuna
                const buttonCircleShape = new THREE.Shape();
                //srediste je na sredini 
                //APSCISA X -> livi x +(desni x - livi x) /2
                //ORDINATA Y -> donji y + gornji y - donji y) / 2
                //RADIJUS -> (DESNIX - LIVI X)/2, ISTO KAO SREDISTE, MOZE I S VISINOM NA ISTI NACIN JER JE KVADRAT
                buttonCircleShape.absarc(bottomLeftX+buttonFrameRadius+(bottomLeftX+width-buttonFrameRadius - (bottomLeftX+buttonFrameRadius))/2, bottomLeftY+buttonFrameRadius+(bottomLeftY+height-buttonFrameRadius - (bottomLeftY+buttonFrameRadius))/2, (bottomLeftX+width-buttonFrameRadius - (bottomLeftX+buttonFrameRadius))/2, 0, 2 * Math.PI, false );
                let buttonCircleMaterial = new THREE.MeshPhongMaterial( { color: 0x2F4F4F } );
                let buttonCircleGeometryl= new THREE.ExtrudeGeometry(buttonCircleShape, circleExtrudeSettings);
                const buttonCircle = new THREE.Mesh( buttonCircleGeometryl, buttonCircleMaterial );
                buttonCircle.rotation.y=2.66-Math.PI;
                buttonCircle.translateZ(frontDeviceShapeDepth+0.001+buttonBaseDepth+buttonBevelDepth);
                scene.add(buttonCircle)
            }

            function addButtonHole(shape,bottomLeftX,bottomLeftY,width,height)
            {
                let buttonHole=new THREE.Path()
                buttonHole.moveTo(bottomLeftX,bottomLeftY);
                buttonHole.lineTo(bottomLeftX,bottomLeftY+height);
                buttonHole.lineTo(bottomLeftX+width,bottomLeftY+height);
                buttonHole.lineTo(bottomLeftX+width,bottomLeftY);
                buttonHole.lineTo(bottomLeftX,bottomLeftY);
                shape.holes.push(buttonHole);
            }

            function addButtonFrame(scene,buttonBottomLeftX,buttonBottomLeftY,buttonWidth,buttonHeight,buttonFrameMaterial)
            {
                const buttonFrameOffset=0.01,buttonFrameThickness=0.005, buttonFrameRadius=0.01;
                
                const buttonFrame= new THREE.Shape();
                buttonFrame.moveTo(buttonBottomLeftX,buttonBottomLeftY-buttonFrameRadius)//kreni od donjeg livog dijela prije zaobljenog dijela
                buttonFrame.quadraticCurveTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY-buttonFrameRadius,buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY);//donji livi zaobljeni dio
                buttonFrame.lineTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY+buttonHeight);
                buttonFrame.quadraticCurveTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius,buttonBottomLeftX+buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius)//gornji lijevi zaobljeni dio
                buttonFrame.lineTo(buttonBottomLeftX+buttonWidth,buttonBottomLeftY+buttonHeight+buttonFrameRadius)
                buttonFrame.quadraticCurveTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius,buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY+buttonHeight)//gornji desni ugao
                buttonFrame.lineTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY);
                buttonFrame.quadraticCurveTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY-buttonFrameRadius,buttonBottomLeftX+buttonWidth,buttonBottomLeftY-buttonFrameRadius)//donji desni ugao
                buttonFrame.lineTo(buttonBottomLeftX,buttonBottomLeftY-buttonFrameRadius)

                addButtonHole(buttonFrame,buttonBottomLeftX,buttonBottomLeftY,buttonWidth,buttonHeight);

                const buttonFrameExtrudeSettings={
                    steps:1,
                    depth:frontDeviceShapeDepth+0.01,
                    bevelEnabled:false
                }


                const buttonFrameGeometry= new THREE.ExtrudeGeometry(buttonFrame,buttonFrameExtrudeSettings);
                const buttonFrameMesh=new THREE.Mesh(buttonFrameGeometry,buttonFrameMaterial);
                buttonFrameMesh.rotation.y=2.66-Math.PI;
                //buttonFrameMesh.rotation.z=-Math.PI/2//jer se rotira za 90 kad se koristi extrusion path, potrebno odrodirat
                scene.add(buttonFrameMesh)

            }

            function generateFrontDeviceShape(scene)
            {

                const frontDeviceFaceShape= new THREE.Shape();

                frontDeviceFaceShape.moveTo(-deviceWidth/2+deviceCornerRadius,deviceHeight/2);
                frontDeviceFaceShape.lineTo(deviceWidth/2-deviceCornerRadius,deviceHeight/2);//gornji dio devicea
                frontDeviceFaceShape.quadraticCurveTo(deviceWidth/2, deviceHeight/2, deviceWidth/2, deviceHeight/2-deviceCornerRadius);//desni gornji ugao
                frontDeviceFaceShape.lineTo(deviceWidth/2,-deviceHeight/2+deviceCornerRadius);
                frontDeviceFaceShape.quadraticCurveTo(deviceWidth/2, -deviceHeight/2, deviceWidth/2-deviceCornerRadius, -deviceHeight/2);//desni donji ugao
                frontDeviceFaceShape.lineTo(-deviceWidth/2+deviceCornerRadius,-deviceHeight/2);
                frontDeviceFaceShape.quadraticCurveTo(-deviceWidth/2, -deviceHeight/2, -deviceWidth/2, -deviceHeight/2+deviceCornerRadius);//livi donji ugao
                frontDeviceFaceShape.lineTo(-deviceWidth/2,deviceHeight/2-deviceCornerRadius);
                frontDeviceFaceShape.quadraticCurveTo(-deviceWidth/2, deviceHeight/2, -deviceWidth/2+deviceCornerRadius, deviceHeight/2);//livi gornji ugao

                //dodaj rupe

                //DODAJ RUPU ZA EKRAN
                let screenHole=new THREE.Path();
                screenHole.moveTo(-0.416*deviceWidth/2,0.1619*deviceHeight);
                screenHole.lineTo(-0.416*deviceWidth/2,0.1619*deviceHeight+0.416*deviceWidth);
                screenHole.lineTo(0.416*deviceWidth/2,0.1619*deviceHeight+0.416*deviceWidth);
                screenHole.lineTo(0.416*deviceWidth/2,0.1619*deviceHeight);
                screenHole.lineTo(-0.416*deviceWidth/2,0.1619*deviceHeight);
                frontDeviceFaceShape.holes.push(screenHole);

                //RUPE ZA BOTUNE + BOTUNI
                const buttonWidth = deviceHeight*0.06, buttonHeight = deviceHeight*0.06,buttonBaseDepth=0.01, buttonBevelDepth=0.005;

                const buttonExtrudeSettings = {
                    steps: 2,
                    depth: buttonBaseDepth,
                    bevelEnabled: true,
                    bevelThickness: buttonBevelDepth,
                    bevelSize: 0.01,
                    bevelOffset: 0,
                    bevelSegments: 1
                };

                const buttonCircleDepth=0.0165//dubina kruga na prednjen dijelu botuna

                const circleExtrudeSettings = {
                    steps: 2,
                    depth: buttonCircleDepth,
                    curveSegments:50,
                    bevelEnabled: false
                };

                const buttonFrameMaterial= new THREE.MeshPhongMaterial( { color: 0x2F4F4F , side:THREE.FrontSide } );

                //LIVI
                addButtonHole(frontDeviceFaceShape,-(0.4166*deviceWidth/2+buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight)
                //dodaj okvir oko botuna
                //okvir ima oblik kvadrata sa malo zaboljenim rubovima -> koristi quadratic curve
                //napravi okvir za zaobljenim rubom i u njemu dodaj rupu i extrudaj
                addButtonFrame(scene,-(0.4166*deviceWidth/2+buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight,buttonFrameMaterial)
                generateButton(scene,-(0.4166*deviceWidth/2+buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight)
                
                //DESNI
                addButtonHole(frontDeviceFaceShape,(0.4166*deviceWidth/2-buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight)
                addButtonFrame(scene,(0.4166*deviceWidth/2-buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight,buttonFrameMaterial)
                generateButton(scene,(0.4166*deviceWidth/2-buttonWidth/2),-buttonHeight,buttonWidth,buttonHeight)

                //GORNJI SREDNJI
                addButtonHole(frontDeviceFaceShape,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight),buttonWidth,buttonHeight)
                addButtonFrame(scene,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight),buttonWidth,buttonHeight,buttonFrameMaterial)
                generateButton(scene,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight),buttonWidth,buttonHeight)

                //DONJI SREDNJI
                addButtonHole(frontDeviceFaceShape,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight-0.133*deviceHeight-buttonHeight),buttonWidth,buttonHeight)
                addButtonFrame(scene,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight-0.133*deviceHeight-buttonHeight),buttonWidth,buttonHeight,buttonFrameMaterial)
                generateButton(scene,-buttonWidth/2,(-buttonHeight-0.02857*deviceHeight-buttonHeight-0.133*deviceHeight-buttonHeight),buttonWidth,buttonHeight)

                const frontDeviceFaceGeometry=new THREE.ExtrudeGeometry( frontDeviceFaceShape, frontDeviceFaceExtrussionSettings );
                const frontFace= new THREE.Mesh(frontDeviceFaceGeometry, deviceMaterial)
                frontFace.rotation.y=2.66-Math.PI;
                scene.add(frontFace);
            }

            function generateDeviceScreen(scene)
            {
                //atributi koje daje three.js u shadere po defualtu https://threejs.org/docs/index.html?q=web#api/en/renderers/webgl/WebGLProgram
                /*Note that you can therefore calculate the position of a vertex in the vertex shader by:
gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );*/
                //varyingi se korsite za dijeljenje izmedu veertex i fragment shadera, npr koristimo u fragment shader uv kooridnate za svaki pixel
                const deviceScreenVertexShader=`

                    varying vec2 vertexUV;

                    void main(){

                        vertexUV=uv;//imamo pristup uv vekotur po defualtu od three.js

                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `

                //slika je velicine 1787*435 pixela, zelimo zadrzat njen aspect ratio
                const deviceScreenFragmentShader=`

                varying vec2 vertexUV;

                uniform sampler2D deviceScreenTexture;

                    void main(){
                        //texture2d na temelju u v koordinata od texture vraća boju za taj pixel
                        gl_FragColor = vec4(texture2D(deviceScreenTexture, vertexUV).rgb, 1.0);
                    }
                `


                let deviceBaseScreenGeometry = new THREE.PlaneBufferGeometry(deviceWidth*0.416,deviceWidth*0.416);//baza koja uvik daje bilu pizadinu d onog sta ne zauzme glamos logo slika

                let deviceScreenGeometry = new THREE.PlaneBufferGeometry(deviceWidth*0.416,deviceWidth*0.416*(1403/1500));

                let deviceScreenMaterial;

                textureLoader.load(
                    // resource URL
                    'textures/logo.png',

                    // onLoad callback
                    function ( screenTexture ) {
                        const deviceScreenMaterial=new THREE.MeshBasicMaterial({//ekran uvik svitli neovisno o izvoru svjetla, ne stavljamko phong mateirjal
                            map:screenTexture
                        })
                        const deviceScreen = new THREE.Mesh(deviceScreenGeometry,deviceScreenMaterial);
                        deviceScreen.rotation.y=2.66-Math.PI;
                        deviceScreen.translateZ(0.01)
                        deviceScreen.translateY(0.1619*deviceHeight+0.416*deviceWidth/2);
                        scene.add(deviceScreen);

                        const deviceBaseScreenMaterial=new THREE.MeshBasicMaterial({
                            color:0xffffff
                        });
                        const deviceBaseScreen= new THREE.Mesh(deviceBaseScreenGeometry,deviceBaseScreenMaterial);
                        deviceBaseScreen.rotation.y=2.66-Math.PI;
                        deviceBaseScreen.translateZ(0.005);
                        deviceBaseScreen.translateY(0.1619*deviceHeight+0.416*deviceWidth/2);
                        scene.add(deviceBaseScreen);
                    },

                    // onProgress callback currently not supported
                    undefined,

                    // onError callback
                    function ( err ) {
                        console.error( 'An error happened.' );
                    }
                );

                //napravi obrube crne boje u dubini ekrana da se istice
                //napravi 4 pravokutnika i rotiraj ih i translatirja na te rubove
                const ScreenDividersMaterial=new THREE.MeshPhongMaterial({
                    color:0x000000,
                    side:THREE.DoubleSide
                })
                //livi rub
                const leftScreenDividerGeometry=new THREE.PlaneBufferGeometry(frontDeviceShapeDepth,0.416*deviceWidth);
                const leftScreenDivider=new THREE.Mesh(leftScreenDividerGeometry,ScreenDividersMaterial);
                leftScreenDivider.rotation.y=2.66-Math.PI+Math.PI/2//rotiraj za 9 u odnosu na ekran
                leftScreenDivider.translateX(-frontDeviceShapeDepth+frontDeviceShapeDepth/2);//poravnaj po dubini
                leftScreenDivider.translateZ(-0.416*deviceWidth/2);//poravnaj na lijevi rub ekrana
                leftScreenDivider.translateY(0.1619*deviceHeight+0.416*deviceWidth/2)//podigni do ekrana
                scene.add(leftScreenDivider);
                //desni rub
                const rightScreenDividerGeometry=new THREE.PlaneBufferGeometry(frontDeviceShapeDepth,0.416*deviceWidth);
                const rightScreenDivider=new THREE.Mesh(rightScreenDividerGeometry,ScreenDividersMaterial);
                rightScreenDivider.rotation.y=2.66-Math.PI+Math.PI/2
                rightScreenDivider.translateX(-frontDeviceShapeDepth+frontDeviceShapeDepth/2);//poravnaj po dubini
                rightScreenDivider.translateZ(0.416*deviceWidth/2);//poravnaj na desni rub ekrana
                rightScreenDivider.translateY(0.1619*deviceHeight+0.416*deviceWidth/2)//podigni do ekrana
                scene.add(rightScreenDivider);
                //gornji rub
                const topScreenDividerGeometry=new THREE.PlaneBufferGeometry(0.416*deviceWidth,frontDeviceShapeDepth);
                const topScreenDivider=new THREE.Mesh(topScreenDividerGeometry,ScreenDividersMaterial);
                topScreenDivider.rotation.x=-Math.PI/2;
                topScreenDivider.rotation.z=2.66-Math.PI;
                topScreenDivider.translateZ(0.1619*deviceHeight+0.416*deviceWidth)
                topScreenDivider.translateY(-frontDeviceShapeDepth+frontDeviceShapeDepth/2)
                scene.add(topScreenDivider);
                //donji rub
                const bottomScreenDividerGeometry=new THREE.PlaneBufferGeometry(0.416*deviceWidth,frontDeviceShapeDepth);
                const bottomScreenDivider=new THREE.Mesh(bottomScreenDividerGeometry,ScreenDividersMaterial);
                bottomScreenDivider.rotation.x=-Math.PI/2;
                bottomScreenDivider.rotation.z=2.66-Math.PI;
                bottomScreenDivider.translateZ(0.1619*deviceHeight)
                bottomScreenDivider.translateY(-frontDeviceShapeDepth+frontDeviceShapeDepth/2)
                scene.add(bottomScreenDivider);

            }

            function generateDeviceTopAntennaRing(scene)//napravi prsten na dnu antene na vrhu uređaja
            {
                let antennaBottomRingExtrudeSettings={
                    //steps: 2,
                    curveSegments:50,
                    steps:30,
                    depth: antennaBottomRingDepth,
                    bevelEnabled: true,
                    bevelSize: 0.03, 
                    bevelThickness: 0.05,
                    bevelSegments:30
                }
                //zbog bevela će rubovi di se spajjau 0 i 2pi ostat crtica/praznina jer se tu primjenuuje, zato vucemo prvi krug skoro do 2PI TAKO DA BEVEL POPUNI TAJ DIO KAD SE NAPRAVI
                let antennaBottomRingShape1=new THREE.Shape();
                //let antennaBottomRingShape2=new THREE.Shape();

                antennaBottomRingShape1.absarc(0,0,antennaRadius,0, 1.99*Math.PI, false)
                //antennaBottomRingShape2.absarc(0,0,antennaRadius,0,2.01*Math.PI,true)

                const antennaBottomRingGeometry1=new THREE.ExtrudeGeometry(antennaBottomRingShape1,antennaBottomRingExtrudeSettings);
                //const antennaBottomRingGeometry2=new THREE.ExtrudeGeometry(antennaBottomRingShape2,antennaBottomRingExtrudeSettings);

                const antennaBottomRing1=new THREE.Mesh(antennaBottomRingGeometry1,antennaBottomRingNutMaterial);
                //const antennaBottomRing2=new THREE.Mesh(antennaBottomRingGeometry2,antennaBottomRingNutMaterial);

                //ROTIRAJ DA BUDU USPRAVNI
                antennaBottomRing1.rotation.x=-Math.PI/2;
                antennaBottomRing1.rotation.z=2.66-Math.PI;
                //antennaBottomRing2.rotation.x=-Math.PI/2;
                //antennaBottomRing2.rotation.z=2.66;

                //TRANSLATIRAJ NA VRH UREDAJA
                antennaBottomRing1.translateZ(deviceHeight/2+0.05);//nadodjamo bevel thickness jer kad se zarotira DONJI KRUG JE U ISHODISTU ISPOD NJEGA JE NADODAN BEVEL THICKNESS A IZNAD NJEGA SE NALAZI OSTATAK EXTERUDANOG OBLIKA VISINE EXTRUDEDEPTH+GORNJI BEVEL
                antennaBottomRing1.translateX(antennaHorizontalPosition);
                antennaBottomRing1.translateY((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth)//stavi srediste antene na srediste debljine uredaja -> DEBLJINA UREDAJA-> frontDeviceShapeDepth+deviceExtrudeDepth, nase srediste se nalazi di i pocetak extrudanong straznjeg dijela uredaja-> pomicemo srediste do sredine uredaja a to je jos sredina-debljina prednje strane uredaja

                //antennaBottomRing2.translateZ(height/2+0.1);
                //antennaBottomRing2.translateX(antennaHorizontalPosition);
/*                 let deviceScreenGeometry = new THREE.PlaneBufferGeometry(2,1);
                const deviceScreen = new THREE.Mesh(deviceScreenGeometry,antennaBottomRingNutMaterial);
                deviceScreen.rotation.x=-Math.PI/2;
                deviceScreen.translateZ(antennaBottomRingDepth);
                scene.add(deviceScreen); */
                scene.add(antennaBottomRing1);
                //scene.add(antennaBottomRing2);



                
            }

            function generateDeviceTopAntennaHexagonNut(scene)//napravi maticu iznad prstena na vrhu uređaja
            {
                let antennaHexagonNutExtrudeSettings={
                    //steps: 2,
                    curveSegments:50,
                    steps:30,
                    depth: antennaHexagonNutDepth,
                    bevelEnabled: true,
                    bevelSize: 0.03, 
                    bevelThickness: 0.05,
                    bevelSegments:30
                }
                //hexagon-> duljina stranice a jednaka je radijusu kruznice
                let antennaHexagonNutShape=new THREE.Shape();
                let hexagonTriangleSideLength=antennaRadius;//stranica hexagona je jednaka radijusu
                let hexagonTriangleHeight=0.866*antennaRadius;//to je √3/2 a

                antennaHexagonNutShape.moveTo(hexagonTriangleSideLength/2,-hexagonTriangleHeight)//donja liva tocka
                antennaHexagonNutShape.lineTo(hexagonTriangleSideLength,0);//livi srednji
                antennaHexagonNutShape.lineTo(hexagonTriangleSideLength/2,hexagonTriangleHeight);//livio gornji
                antennaHexagonNutShape.lineTo(-hexagonTriangleSideLength/2,hexagonTriangleHeight);//desni gornji
                antennaHexagonNutShape.lineTo(-hexagonTriangleSideLength,0)//desni srednji
                antennaHexagonNutShape.lineTo(-hexagonTriangleSideLength/2,-hexagonTriangleHeight);//desni donji
                antennaHexagonNutShape.lineTo(hexagonTriangleSideLength/2,-hexagonTriangleHeight)

                const antennaHexagonNutGeometry=new THREE.ExtrudeGeometry(antennaHexagonNutShape,antennaHexagonNutExtrudeSettings)
            
                const antennaHexagonNut=new THREE.Mesh(antennaHexagonNutGeometry,antennaBottomRingNutMaterial)
                
                //ROTIRAJ DA BUDU USPRAVNI
                antennaHexagonNut.rotation.x=-Math.PI/2;
                antennaHexagonNut.rotation.z=2.66-Math.PI;
                //antennaBottomRing2.rotation.x=-Math.PI/2;
                //antennaBottomRing2.rotation.z=2.66;

                //TRANSLATIRAJ
                antennaHexagonNut.translateZ(deviceHeight/2+0.05+antennaBottomRingDepth+0.05+0.05);//sa height/2+0.05 dodemo na vrh uredaja i onda trebamo doc tocno iznad prstena-> potrebno dodat njegovu dvostruku debljinu(jer bevel ide u 2 smjera)
                antennaHexagonNut.translateX(antennaHorizontalPosition);
                antennaHexagonNut.translateY((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth)//stavi srediste antene na srediste debljine uredaja -> DEBLJINA UREDAJA-> frontDeviceShapeDepth+deviceExtrudeDepth, nase srediste se nalazi di i pocetak extrudanong straznjeg dijela uredaja-> pomicemo srediste do sredine uredaja a to je jos sredina-debljina prednje strane uredaja

                //antennaBottomRing2.translateZ(height/2+0.1);
                //antennaBottomRing2.translateX(antennaHorizontalPosition);
                scene.add(antennaHexagonNut);
            }

            function generateDevicAntennaTopPart(scene)//napravi antenu na vrhu ređaja koja se satoji od 3 dijela(NBROJANA PO REDU OD DOLI PREMA GORE) -> VALJAK, PRSTEN, POLOVICA SFERE(KAPICA NA VRHU, Sphere geomtry, kut theta namisti)
            {
                //DODAJ VALJAK
                let antennaMiddleCilinderShape=new THREE.Shape();

                let antennaCilinderExtrudeSettings={
                    //steps: 2,
                    curveSegments:50,
                    steps:30,
                    depth: antennaCilinderHeight,
                    bevelEnabled: true,
                    bevelSize: 0.01, 
                    bevelThickness: 0.05,
                    bevelSegments:30
                }

                antennaMiddleCilinderShape.absarc(0,0,antennaRadius,0, 1.995*Math.PI, false)

                const antennaMiddleCilinderGeometry=new THREE.ExtrudeGeometry(antennaMiddleCilinderShape,antennaCilinderExtrudeSettings);

                const antennaMiddleCilinder=new THREE.Mesh(antennaMiddleCilinderGeometry,antennaTopPartMaterial)

                //ROTIRAJ DA BUDU USPRAVNI
                antennaMiddleCilinder.rotation.x=-Math.PI/2;
                antennaMiddleCilinder.rotation.z=2.66-Math.PI;
                //antennaBottomRing2.rotation.x=-Math.PI/2;
                //antennaBottomRing2.rotation.z=2.66;

                //TRANSLATIRAJ                                              //nema bevela NADODAJEMO 2 BEVELA OD PRSTENA, 2 BEVELA OD MATICE I NJIHOVE DUBINE ZA DOC NA VRH
                antennaMiddleCilinder.translateZ(deviceHeight/2+0.05+antennaBottomRingDepth+0.05+0.05+antennaHexagonNutDepth+0.05+0.05);//sa height/2+0.1 dodemo na vrh uredaja i onda trebamo doc tocno iznad prstena-> potrebno dodat njegovu dvostruku debljinu(jer bevel ide u 2 smjera)
                antennaMiddleCilinder.translateX(antennaHorizontalPosition);
                antennaMiddleCilinder.translateY((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth)//stavi srediste antene na srediste debljine uredaja -> DEBLJINA UREDAJA-> frontDeviceShapeDepth+deviceExtrudeDepth, nase srediste se nalazi di i pocetak extrudanong straznjeg dijela uredaja-> pomicemo srediste do sredine uredaja a to je jos sredina-debljina prednje strane uredaja

                scene.add(antennaMiddleCilinder);

                //DODAJ PRSTEN U SREDINI
                let antennaMiddleRingShape=new THREE.Shape();

                let antennaMiddleRingExtrudeSettings={
                    //steps: 2,
                    curveSegments:50,
                    steps:30,
                    depth: antennaBottomRingDepth*0.75,//25% manja dubina od onog na dnu
                    bevelEnabled: true,
                    bevelSize: 0.01, 
                    bevelThickness: 0.05,
                    bevelSegments:30
                }

                antennaMiddleRingShape.absarc(0,0,antennaRadius,0, 2*Math.PI, false)

                const antennaMiddleRingGeometry=new THREE.ExtrudeGeometry(antennaMiddleRingShape,antennaMiddleRingExtrudeSettings)

                const antennaMiddleRing=new THREE.Mesh(antennaMiddleRingGeometry,antennaTopPartMaterial);

                //ROTIRAJ DA BUDU USPRAVNI
                antennaMiddleRing.rotation.x=-Math.PI/2;
                antennaMiddleRing.rotation.z=2.66-Math.PI;
                //antennaBottomRing2.rotation.x=-Math.PI/2;
                //antennaBottomRing2.rotation.z=2.66;

                //TRANSLATIRAJ                                              
                antennaMiddleRing.translateZ(deviceHeight/2+0.05+antennaBottomRingDepth+0.05+0.05+antennaHexagonNutDepth+0.05+antennaCilinderHeight+0.05+0.05+0.05);//kada srediste dode di i gornji dio valjka triba ga jos dignit za antennaBottomRingDept/2 + bevel thickness(0.02)
                antennaMiddleRing.translateX(antennaHorizontalPosition);
                antennaMiddleRing.translateY((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth)//stavi srediste antene na srediste debljine uredaja -> DEBLJINA UREDAJA-> frontDeviceShapeDepth+deviceExtrudeDepth, nase srediste se nalazi di i pocetak extrudanong straznjeg dijela uredaja-> pomicemo srediste do sredine uredaja a to je jos sredina-debljina prednje strane uredaja

                scene.add(antennaMiddleRing);

                //dodaj kuglinu kapicu na vrh odnosno pola sfere
                                                                            //uracunaj i srinu bevela u radijus da bude kao i srina valjka i prstena
                const antennaTopHalfSphereGeometry = new THREE.SphereGeometry( antennaRadius+0.01/2, 50, 30, 0, 2*Math.PI,Math.PI/2,Math.PI );
                const antennaTopHalfSphere = new THREE.Mesh( antennaTopHalfSphereGeometry, antennaTopPartMaterial );
                //rotiraj
                antennaTopHalfSphere.rotation.x=-Math.PI;//osi iste kao kod normalnog x samo drugi predznaci -> x i y osi di su prije isli s + sad su -, x ostaje nepromjenjen, rotirali se oko x za 180
                antennaTopHalfSphere.rotation.y=-(2.66-Math.PI);
                //translatiraj
                antennaTopHalfSphere.translateY(-(deviceHeight/2+0.05+antennaBottomRingDepth+0.05+0.05+antennaHexagonNutDepth+0.05+antennaCilinderHeight+0.05+0.05+0.05+antennaBottomRingDepth*0.75+0.05));//kada srediste dode di i gornji dio valjka triba ga jos dignit za antennaBottomRingDept/2 + bevel thickness(0.02)
                antennaTopHalfSphere.translateZ(((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth))
                antennaTopHalfSphere.translateX(antennaHorizontalPosition);

                scene.add( antennaTopHalfSphere );

            }

            function generateGlamosLabels(scene)
            {

                //generiraj PREDNJI DONJI LABEL
                textureLoader.load(
                    // resource URL
                    'textures/logo-transparent.png',

                    // onLoad callback
                    function ( logoTexture ) {

                        const frontBottomLogoMaterial=new THREE.MeshPhongMaterial({//ekran uvik svitli neovisno o izvoru svjetla, ne stavljamko phong mateirjal
                            transparent: true,
                            map:logoTexture
                        })
                        const frontBottomLogoGeometry = new THREE.PlaneBufferGeometry(0.3833*deviceWidth,0.3833*deviceWidth*435/1787);
                        const frontBottomLogo = new THREE.Mesh(frontBottomLogoGeometry,frontBottomLogoMaterial);
                        frontBottomLogo.rotation.y=2.66-Math.PI;
                        frontBottomLogo.translateZ(frontDeviceShapeDepth+0.01)
                        frontBottomLogo.translateY(-buttonHeight-0.02857*deviceHeight-buttonHeight-0.133*deviceHeight-buttonHeight-0.0714*deviceHeight);
                        scene.add(frontBottomLogo);
                    },

                    // onProgress callback currently not supported
                    undefined,

                    // onError callback
                    function ( err ) {
                        console.error( 'An error happened.' );
                    }
                );

                //generiraj PREDNJI DONJI LABEL
                textureLoader.load(
                // resource URL
                'textures/logo.png',

                // onLoad callback
                function ( logoTexture ) {

                    const deviceBackLogoMaterial=new THREE.MeshPhongMaterial({//ekran uvik svitli neovisno o izvoru svjetla, ne stavljamko phong mateirjal
                        transparent: true,
                        side:THREE.DoubleSide,
                        map:logoTexture
                    })
                    const deviceBackLogoGeometry = new THREE.PlaneBufferGeometry(0.5*deviceWidth,0.5*deviceWidth*(1403/1500));
                    const deviceBackLogo = new THREE.Mesh(deviceBackLogoGeometry,deviceBackLogoMaterial);
                    deviceBackLogo.rotation.y=2.66-Math.PI-Math.PI;
                    deviceBackLogo.translateZ(deviceExtrudeDepth+0.01)
                    deviceBackLogo.translateY(0.2047*deviceHeight);
                    scene.add(deviceBackLogo);
                },

                // onProgress callback currently not supported
                undefined,

                // onError callback
                function ( err ) {
                    console.error( 'An error happened.' );
                }
            );


            }

            function updateButtonMesh()
            {
                buttonExtrudeSettings.steps=world.button.extrusionSteps;
                buttonExtrudeSettings.depth=world.button.extrusionDepth;
                buttonExtrudeSettings.bevelThickness=world.button.extrusionBevelThickness;
                buttonExtrudeSettings.bevelSize=world.button.extrusionBevelSize;
                buttonExtrudeSettings.bevelOffset=world.button.extrusionBevelOffset;
                buttonExtrudeSettings.bevelSegments=world.button.extrusionBevelSegments;
                button.geometry = new THREE.ExtrudeGeometry( buttonShape, buttonExtrudeSettings );
            }
            let deviceFolder=gui.addFolder('device');//ovako se dodaju folderi -> grupiraj parametre po znacenjima raddvoji svitla i objekt 
            deviceFolder.add(world.device, 'width', 1, 20).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'height', 1, 20).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'radius', 0.1, 5).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateX', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateY', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateZ', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'extrusionSteps', 0, 10,1).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'extrusionDepth', 0, 10,0.1).onChange(updateDeviceMesh)
            let deviceBottomFolder=gui.addFolder('deviceBottom');
            deviceBottomFolder.add(world.deviceBottom, 'rotateX',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            deviceBottomFolder.add(world.deviceBottom, 'rotateY',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            deviceBottomFolder.add(world.deviceBottom, 'rotateZ',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            let frontLightFolder=gui.addFolder('frontLight');
            frontLightFolder.add(world.frontLight,'x',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));
            frontLightFolder.add(world.frontLight,'y',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));
            frontLightFolder.add(world.frontLight,'z',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));;
            let backLightFolder=gui.addFolder('backLight');
            backLightFolder.add(world.backLight,'x',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));
            backLightFolder.add(world.backLight,'y',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));;
            backLightFolder.add(world.backLight,'z',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));;
            let buttonFolder=gui.addFolder('button');
            buttonFolder.add(world.button,'extrusionSteps',0,10,1).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionDepth',0,1,0.01).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelThickness',0,2,0.05).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelSize',0,2,0.05).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelOffset',0,5,0.1).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelSegments',1,5,1).onChange(updateButtonMesh);

            //dubini cijelog uredaja(front i back side) s bevelom donjeg dijela treba biti 0.2*height=1.2
            var deviceHeight=6,deviceWidth=4,deviceCornerRadius=0.5,deviceMiddleBottomPartDepth=0.1,deviceExtrudeDepth=1.1,frontDeviceShapeDepth=0.1;

            //extrude postavke za dijelove uredaja -> extrudamo ih prema nazad a ostalo se sve po defualtu extruda prema naprijed
            var backDevicev1 = new THREE.Vector3(0, 0, 0);

            var backDevicev2 = new THREE.Vector3(0, 0, -deviceExtrudeDepth);

            var backDeviceExtrusionPath = new THREE.LineCurve3(backDevicev1, backDevicev2)

            var deviceLeftRightMiddleTopExtrudeSettings = {
                steps: 1,
                bevelEnabled: false,
                extrudePath:backDeviceExtrusionPath
            };

            //on nam se nakon rotacije ide od gore prema dole tako da ne triba definirat smjer extrusiona
            var deviceMiddleBottomExtrudeSettings={
                steps:1,
                depth:0.1,
                bevelEnabled:false
            }

            //EXTRUDE OPCIJE ZA PREDNJI DIO EKRANA
            var frontDeviceFaceExtrussionSettings={
                steps:1,
                depth:frontDeviceShapeDepth,
                bevelEnabled:false
            }

            //incijalizacija scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight,0.01, 1000 );

            const renderer = new THREE.WebGLRenderer({
                alpha:true,//da pozadina slike ekrana koja je transparent ne bude postavljena na transparent od browsera odnosno sivkasta
                antialias:true//makni probleme kod rubova di nisu glatke linije
            });
            renderer.setClearColor( 0x000000 );//boja pozadine
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            let orbitControls = new THREE.OrbitControls(camera, renderer.domElement);//za mogucnost kretanja oko objekta pomocu misa
        

            //ucitaj materijal za uredaj i onda kreni s iscrtavanjem
            var deviceMaterial;
/*             var deviceMaterial2=new THREE.MeshPhongMaterial({
                color:0xff0000
            }) */
            var switchDividersMaterial;
            //PARAMETRI ZA DIJELOVE UREDAJA KOJIMA SE MIENJJA BOJA OVISNO O ODABIRU-> TZREBAJU BIT U GLAVNOM PROGRAMU I GLOBALNO DOSTUPNI ZBOG MOGUCNOSTI PROMJENE BOJA NA KLIK
            //lijevi dio uredaja
            var deviceLeftPart;
            //desni dio uredaja
            var deviceRightPart;
            //srednji gornji dio uredaja
            var deviceMiddleTopPart;
            //srednji donji dio uredaja
            var deviceMiddleBottomPart;
            //kosi obrubi oko switcha
            var topSwitchDivider;
            var rightSwitchDivider;
            var leftSwitchDivider;
            var bottomSwitchDivider;

            //ZA UCITAVANJE TEXTURA
            var textureLoader = new THREE.TextureLoader();

            textureLoader.load('textures/white-texture.png',
            // onLoad callback
            function ( deviceTexture ) {
                deviceTexture.wrapS=THREE.RepeatWrapping;
                deviceTexture.wrapT=THREE.RepeatWrapping;
                deviceTexture.repeat.set(10,10)//odredujemo finocu prikaza odnosono koliko ce hih bit vertikalno i horizontalno
                deviceMaterial=new THREE.MeshPhongMaterial({//ekran uvik svitli neovisno o izvoru svjetla, ne stavljamko phong mateirjal
                    map:deviceTexture,
                })
                switchDividersMaterial=new THREE.MeshPhongMaterial({
                    map:deviceTexture,
                    side:THREE.BackSide//potreban zbog rotacije
                })
                generateDeviceLeftShape(scene);
                generateDeviceRightShape(scene);
                generateDeviceMiddleTopShape(scene);
                generateDeviceMiddleBottomShape(scene);
                //PREDNJI DIO EKRANA
                generateFrontDeviceShape(scene);
                console.log(deviceMiddleTopPart);
            },

            // onProgress callback
            undefined,

            // onError callback
            function ( err ) {
                console.error( 'An error happened.' );
                //ispisi div tag koji govori da je error
            }
            )
 
            //bijelo svijetlo njjaceg itneziteta, directionall ight oponasa dayligght, paralelene zrake
            


            generateDeviceScreen(scene);

            //U DEPTH NIJE UKLJUCENA DEBLJINA BEVELA NA STRANAM EXTRUDANJA -> UKUPNA VISINA JE 2*BEVEL THICKNESS + DEPTH
            //generiraj antenu na vrhu po dijelovima
            //parametri za djelove antene
            let antennaRadius=0.2;
            let antennaHorizontalPosition=-1;//pozicija sredisnjeg dijela antene na vrhu uredaja gledamo horizontalno u odnosu na sirinu uredaja
            let antennaBottomRingDepth=0.1;//prsten na dnu
            let antennaHexagonNutDepth=0.2;//sesterokutasta matica
            let antennaCilinderHeight=2;//visina valjka ispod kugline kapice

            let antennaBottomRingNutMaterial=new THREE.MeshStandardMaterial({
                color:0xffc107,
                roughness:0.5,
                metalness:1,
                reflectivity:1,
            })

            let antennaTopPartMaterial=new THREE.MeshPhongMaterial({
                color:0x000000
            })

            generateDeviceTopAntennaRing(scene);

            generateDeviceTopAntennaHexagonNut(scene);

            generateDevicAntennaTopPart(scene);

            generateGlamosLabels(scene);

            const frontLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            frontLight.position.set(0,1,1);
            scene.add(frontLight);

            const backLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            backLight.position.set(0,-1,-1);
            scene.add(backLight);

            const leftLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            leftLight.position.set(-3,1,0);
            scene.add(leftLight);

            const rightLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            rightLight.position.set(3,1,0);
            scene.add(rightLight);

            camera.position.z = 5;
            camera.position.y=5;

            function onWindowResize() {//responsive desgin na resize prozora, prati promjenu velicine prozora tako da mozemo testirat na manjin ekranima, inace se nec minja ovi aspekt i nas uredaj stoji fiksno ko na velikon ekranu pa ce smannivanjen ekrana skroz nestat iz vidiljvig podrucja, samo crnilo
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            }

            window.addEventListener('resize',onWindowResize);


            function animate() {
                requestAnimationFrame( animate );//This will create a loop that causes the renderer to draw the scene every time the screen is refreshed

                renderer.render( scene,camera);
            }
            animate();
		</script>
	</body>
</html>
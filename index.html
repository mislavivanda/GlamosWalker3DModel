<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script src="js/datguimin.js"></script>
        <script src="js/orbitControls.js"></script>
<!--         <script src="https://threejs.org/examples/js/utils/BufferGeometryUtils.js"></script> -->
		<script>
            const gui = new dat.GUI();//za laku promjenu parametara da si mozemo namistit zeljeni oblik
            const world={
                device:{
                    width:4,
                    height:6,
                    radius:0.5,
                    rotateX:0,
                    rotateY:2.66,
                    rotateZ:0,
                    extrusionSteps: 2,
                    extrusionDepth: 1,
                },
                deviceBottom:{
                    rotateX:-Math.PI/2,
                    rotateY:0,
                    rotateZ:2.66
                },
                frontLight:{
                    x:0,
                    y:1,
                    z:1
                },
                backLight:{
                    x:0,
                    y:-1,
                    z:-1
                },
                button:{
                    extrusionSteps: 2,
                    extrusionDepth: 0.01,
                    extrusionBevelThickness: 1,
                    extrusionBevelSize: 0.1,
                    extrusionBevelOffset: 0,
                    extrusionBevelSegments: 1
                }
            }

            function updateDeviceMesh()//poziv kod svake promjene nekog od dat.gui parametara
            {
                device.geometry.dispose();//makni je, ukloni kkao bi mogli rekreirat objekt nakon promjene u slideru
                width=world.device.width;
                height=world.device.height;
                radius=world.device.radius;
                deviceShape=new THREE.Shape();
                generateDeviceShape();
                extrudeSettings.steps=world.device.extrusionSteps;
                extrudeSettings.depth=world.device.extrusionDepth;
                device.geometry = new THREE.ExtrudeGeometry( deviceShape, extrudeSettings );//ovo ce radit rerender jer se minja device objekt koji se dodaje uscenu a scena se rerendera u animation loop
                device.rotation.x = world.device.rotateX
                device.rotation.y = world.device.rotateY;
                device.rotation.z=world.device.rotateZ;
            }

            function updateDeviceBottomMesh()
            {
                deviceMiddleBottomPart.geometry.dispose();
                width=world.device.width;
                height=world.device.height;
                radius=world.device.radius;
                deviceMiddleBottomShape=new THREE.Shape();
                generateDeviceMiddleBottomShape();
/*                 extrudeSettings.steps=world.device.extrusionSteps;
                extrudeSettings.depth=world.device.extrusionDepth; */
                deviceMiddleBottomPart.geometry = new THREE.ExtrudeGeometry( deviceMiddleBottomShape, deviceMiddleBottomExtrudeSettings );//ovo ce radit rerender jer se minja device objekt koji se dodaje uscenu a scena se rerendera u animation loop
                deviceMiddleBottomPart.rotation.x = world.deviceBottom.rotateX
                deviceMiddleBottomPart.rotation.y = world.deviceBottom.rotateY;
                deviceMiddleBottomPart.rotation.z=world.deviceBottom.rotateZ;
            }

            function generateDeviceLeftShape()
            {
                deviceLeftShape.moveTo(-width/2+radius,-height/2);
                //specificiramo tocku srednju di se siku 2 linije povucene iz 2 tocke na krajevima i 1 od te 2 tocke(PRVA TOCKA JE TAMO DI SMO STALI SA LINETO ILI MOVETO)
                deviceLeftShape.quadraticCurveTo(-width/2, -height/2, -width/2, -height/2+radius);//livi donji ugao
                deviceLeftShape.lineTo(-width/2,height/2-radius);
                deviceLeftShape.quadraticCurveTo(-width/2, height/2, -width/2+radius, height/2);//livi gornji ugao */
                deviceLeftShape.lineTo(-width/2+radius,-height/2);//spoji s pocetkon
/*              deviceShape.moveTo(-width/2+radius,height/2);
                deviceShape.lineTo(width/2-radius,height/2);//gornji dio devicea
                deviceShape.quadraticCurveTo(width/2, height/2, width/2, height/2-radius);//desni gornji ugao
                deviceShape.lineTo(width/2,-height/2+radius);
                deviceShape.quadraticCurveTo(width/2, -height/2, width/2-radius, -height/2);//desni donji ugao
                deviceShape.lineTo(-width/2+radius,-height/2);
                deviceShape.quadraticCurveTo(-width/2, -height/2, -width/2, -height/2+radius);//livi donji ugao
                deviceShape.lineTo(-width/2,height/2-radius);
                deviceShape.quadraticCurveTo(-width/2, height/2, -width/2+radius, height/2);//livi gornji ugao */
            }

            function generateDeviceRightShape()
            {
                deviceRightShape.moveTo(width/2-radius,-height/2);
                deviceRightShape.quadraticCurveTo(width/2, -height/2, width/2, -height/2+radius);//desni donji ugao
                deviceRightShape.lineTo(width/2,height/2-radius);
                deviceRightShape.quadraticCurveTo(width/2, height/2, width/2-radius, height/2);//desni gornji ugao
                deviceRightShape.lineTo(width/2-radius,-height/2)//spoji s pocetkon
            }

            function generateDeviceMiddleTopShape()
            {
                //krenemo od dole kao i za left i right
                deviceMiddleTopShape.moveTo(-width/2+radius,-height/2+deviceMiddleBottomPartDepth);
                deviceMiddleTopShape.lineTo(width/2-radius, -height/2+deviceMiddleBottomPartDepth);
                deviceMiddleTopShape.lineTo(width/2-radius, height/2);
                deviceMiddleTopShape.lineTo(-width/2+radius, height/2);
                deviceMiddleTopShape.lineTo(-width/2+radius,-height/2+deviceMiddleBottomPartDepth)//spoji s prvom
            }

            function generateDeviceMiddleBottomShape()
            {
                //donji dio uredaja za rupama za usb c port i on/off botun
                //nacrtamo pravokutnik dimenzija:
                //1)širine kao širina srednjeg dijela uredaja 
                //2) visine kao dubine extrudanja uredaja -> 1 trenutno
                //crtamo ga pocevsi od donjeg dijela middleTop shapea pa prema dole jer cemo ga kasnije zarotirat oko x za 90 stupnjeva
                //dubina extrudanja će biti deviceMiddleBottomPartDepth
                deviceMiddleBottomShape.moveTo(-width/2+radius,-height/2+deviceMiddleBottomPartDepth)
                deviceMiddleBottomShape.lineTo(width/2-radius, -height/2+deviceMiddleBottomPartDepth)
                deviceMiddleBottomShape.lineTo(width/2-radius,-height/2+deviceMiddleBottomPartDepth-1);//-1 dodajemo jer je uredaj bez prednje strane tolike debljine, nama ce ta visina nakon rotacije postat debljina, prednji dio će popunit ostatak a kod crtanja rupa u sredinu cemo morat racunat i debljinu prednjeg dijela
                deviceMiddleBottomShape.lineTo(-width/2+radius,-height/2+deviceMiddleBottomPartDepth-1)
                deviceMiddleBottomShape.lineTo(-width/2+radius, -height/2+deviceMiddleBottomPartDepth);//spoji s pocetnim
                
                //dodaj rupe
                //rupa za cport
                //ima oblik trapeza, zadamo mjere za a i c stranice
                let cPortWidthC=0.5,cPortWidthA=0.3,cPortHeight=0.1;

                let cPortHole= new THREE.Path();
                //pocinjemo crtat od lijeve tocke donje stranice(c)
                //srediste trapeza je u sredini -> sredina donjeg dijela je gornja stranica - (gornja - donja stranica)/2, stavljamo minus jer smo na negativnom dijelu pa 'dodajemo' oduzimanjem  (-height/2+deviceMiddleBottomPartDepth) - [(-height/2+deviceMiddleBottomPartDepth) - (-height/2+deviceMiddleBottomPartDepth-1)]/2 = (-height/2+deviceMiddleBottomPartDepth) - 0.5
                //lijeva tocka će bit udaljena za pola sirine osnovice c od sredista
                cPortHole.moveTo( -cPortWidthC/2 , (-height/2+deviceMiddleBottomPartDepth) - 0.5 - cPortHeight/2)//sredina trapeza ce bit di i sredina donjeg dijela -> spustimo se jos za pola visine za doc na donju stranicu
                cPortHole.lineTo(cPortWidthC/2 , (-height/2+deviceMiddleBottomPartDepth) - 0.5 - cPortHeight/2)//linija do desne tocke osnovice
                cPortHole.lineTo( cPortWidthA/2 , (-height/2+deviceMiddleBottomPartDepth) - 0.5 + cPortHeight/2)//povezi s desnom tockom gornje stranice trapeza a, dizemo se za portHeight pprema gore
                cPortHole.lineTo( -cPortWidthA/2 , (-height/2+deviceMiddleBottomPartDepth) - 0.5 + cPortHeight/2)//povezi s lijevom tockom gornje stranice trapeza a
                cPortHole.lineTo(-cPortWidthC/2 , (-height/2+deviceMiddleBottomPartDepth) - 0.5 - cPortHeight/2)//povezi s pocetkom
                deviceMiddleBottomShape.holes.push(cPortHole);

                //rupa za on/off switch
                let switchWidth=0.5,switchHeight=0.4,distanceBetweenPortAndSwitch=0.3;
                let switchHole=new THREE.Path();
                //ista logika kao za cPortHole samo sta nije trapez nego pravokutnik
                //krenemo od donje lijeve tocke
                //STAVLJAMO NEGATIVNE KOORDINATE JER CEMO KASNIJE ROTACIJOM OKO z zapravo doc na drugu stranu
                switchHole.moveTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-height/2+deviceMiddleBottomPartDepth) - 0.5 - switchHeight/2 )
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch+switchWidth), (-height/2+deviceMiddleBottomPartDepth) - 0.5 - switchHeight/2)//donje desna
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch+switchWidth), (-height/2+deviceMiddleBottomPartDepth) - 0.5 + switchHeight/2)//gornji desni
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-height/2+deviceMiddleBottomPartDepth) - 0.5 + switchHeight/2)//gornji lijevi
                switchHole.lineTo(-(cPortWidthA/2+distanceBetweenPortAndSwitch), (-height/2+deviceMiddleBottomPartDepth) - 0.5 - switchHeight/2)//spoji sa pocetnim
                deviceMiddleBottomShape.holes.push(switchHole);
            }

            function generateButton(scene,bottomLeftX,bottomLeftY,width,height)
            {
                //napravi bazu botuna
                const buttonShape = new THREE.Shape();
                //ne idemo za cijeli width i height od rupe nego idemo do unutarnjih dijelova buttonFrame okvira -> udaljenost od rubova rupe je zapravo radijus buttonFramea
                buttonShape.moveTo( bottomLeftX+buttonFrameRadius,bottomLeftY+buttonFrameRadius);
                buttonShape.lineTo( bottomLeftX+buttonFrameRadius, bottomLeftY+height-buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+width-buttonFrameRadius, bottomLeftY+height-buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+width-buttonFrameRadius, bottomLeftY+buttonFrameRadius );
                buttonShape.lineTo( bottomLeftX+buttonFrameRadius, bottomLeftY+buttonFrameRadius );
                const buttonGeometry = new THREE.ExtrudeGeometry( buttonShape, buttonExtrudeSettings );
                const buttonMaterial = new THREE.MeshPhongMaterial( { color: 0xffff00 , side:THREE.FrontSide } );
                const button = new THREE.Mesh( buttonGeometry, buttonMaterial ) ;
                button.rotation.y = 2.66 - Math.PI;
                button.translateZ(frontDeviceShapeDepth+0.001)
                scene.add( button );

                //napravi okrugli dio na vrhu botuna
                const buttonCircleShape = new THREE.Shape();
                //srediste je na sredini 
                //APSCISA X -> livi x +(desni x - livi x) /2
                //ORDINATA Y -> donji y + gornji y - donji y) / 2
                //RADIJUS -> (DESNIX - LIVI X)/2, ISTO KAO SREDISTE, MOZE I S VISINOM NA ISTI NACIN JER JE KVADRAT
                buttonCircleShape.absarc(bottomLeftX+buttonFrameRadius+(bottomLeftX+width-buttonFrameRadius - (bottomLeftX+buttonFrameRadius))/2, bottomLeftY+buttonFrameRadius+(bottomLeftY+height-buttonFrameRadius - (bottomLeftY+buttonFrameRadius))/2, (bottomLeftX+width-buttonFrameRadius - (bottomLeftX+buttonFrameRadius))/2, 0, 2 * Math.PI, false );
                let buttonCircleMaterial = new THREE.MeshPhongMaterial( { color: 0xffff00 } );
                let buttonCircleGeometryl= new THREE.ExtrudeGeometry(buttonCircleShape, circleExtrudeSettings);
                const buttonCircle = new THREE.Mesh( buttonCircleGeometryl, buttonCircleMaterial );
                buttonCircle.rotation.y=2.66-Math.PI;
                buttonCircle.translateZ(frontDeviceShapeDepth+0.001+buttonBaseDepth+buttonBevelDepth);
                scene.add(buttonCircle)
            }

            function addButtonHole(shape,bottomLeftX,bottomLeftY,width,height)
            {
                let buttonHole=new THREE.Path()
                buttonHole.moveTo(bottomLeftX,bottomLeftY);
                buttonHole.lineTo(bottomLeftX,bottomLeftY+height);
                buttonHole.lineTo(bottomLeftX+width,bottomLeftY+height);
                buttonHole.lineTo(bottomLeftX+width,bottomLeftY);
                buttonHole.lineTo(bottomLeftX,bottomLeftY);
                shape.holes.push(buttonHole);
            }

            function addButtonFrame(scene,buttonBottomLeftX,buttonBottomLeftY,buttonWidth,buttonHeight)
            {
                let buttonFrame= new THREE.Shape();
                buttonFrame.moveTo(buttonBottomLeftX,buttonBottomLeftY-buttonFrameRadius)//kreni od donjeg livog dijela prije zaobljenog dijela
                buttonFrame.quadraticCurveTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY-buttonFrameRadius,buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY);//donji livi zaobljeni dio
                buttonFrame.lineTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY+buttonHeight);
                buttonFrame.quadraticCurveTo(buttonBottomLeftX-buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius,buttonBottomLeftX+buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius)//gornji lijevi zaobljeni dio
                buttonFrame.lineTo(buttonBottomLeftX+buttonWidth,buttonBottomLeftY+buttonHeight+buttonFrameRadius)
                buttonFrame.quadraticCurveTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY+buttonHeight+buttonFrameRadius,buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY+buttonHeight)//gornji desni ugao
                buttonFrame.lineTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY);
                buttonFrame.quadraticCurveTo(buttonBottomLeftX+buttonWidth+buttonFrameRadius,buttonBottomLeftY-buttonFrameRadius,buttonBottomLeftX+buttonWidth,buttonBottomLeftY-buttonFrameRadius)//donji desni ugao
                buttonFrame.lineTo(buttonBottomLeftX,buttonBottomLeftY-buttonFrameRadius)

                addButtonHole(buttonFrame,buttonBottomLeftX,buttonBottomLeftY,buttonWidth,buttonHeight);

                let buttonFrameExtrudeSettings={
                    steps:1,
                    depth:frontDeviceShapeDepth+0.01,
                    bevelEnabled:false
                }


                let buttonFrameGeometry= new THREE.ExtrudeGeometry(buttonFrame,buttonFrameExtrudeSettings);
                let buttonFrameMaterial= new THREE.MeshPhongMaterial( { color: 0xffff00 , side:THREE.FrontSide } );
                let buttonFrameMesh=new THREE.Mesh(buttonFrameGeometry,buttonFrameMaterial);
                buttonFrameMesh.rotation.y=2.66-Math.PI;
                //buttonFrameMesh.rotation.z=-Math.PI/2//jer se rotira za 90 kad se koristi extrusion path, potrebno odrodirat
                scene.add(buttonFrameMesh)

            }

            function generateFrontDeviceShape(scene,frontDeviceFaceShape)
            {
                frontDeviceFaceShape.moveTo(-width/2+radius,height/2);
                frontDeviceFaceShape.lineTo(width/2-radius,height/2);//gornji dio devicea
                frontDeviceFaceShape.quadraticCurveTo(width/2, height/2, width/2, height/2-radius);//desni gornji ugao
                frontDeviceFaceShape.lineTo(width/2,-height/2+radius);
                frontDeviceFaceShape.quadraticCurveTo(width/2, -height/2, width/2-radius, -height/2);//desni donji ugao
                frontDeviceFaceShape.lineTo(-width/2+radius,-height/2);
                frontDeviceFaceShape.quadraticCurveTo(-width/2, -height/2, -width/2, -height/2+radius);//livi donji ugao
                frontDeviceFaceShape.lineTo(-width/2,height/2-radius);
                frontDeviceFaceShape.quadraticCurveTo(-width/2, height/2, -width/2+radius, height/2);//livi gornji ugao

                //dodaj rupe

                //DODAJ RUPU ZA EKRAN
                let screenHole=new THREE.Path();
                screenHole.moveTo(-1,1);
                screenHole.lineTo(-1,2);
                screenHole.lineTo(1,2);
                screenHole.lineTo(1,1);
                screenHole.lineTo(-1,1);
                frontDeviceFaceShape.holes.push(screenHole);

                //RUPE ZA BOTUNE

                //LIVI
                addButtonHole(frontDeviceFaceShape,-1,0.3,buttonWidth,buttonHeight)
                //dodaj okvir oko botuna
                //okvir ima oblik kvadrata sa malo zaboljenim rubovima -> koristi quadratic curve
                //napravi okvir za zaobljenim rubom i u njemu dodaj rupu i extrudaj
                addButtonFrame(scene,-1,0.3,buttonWidth,buttonHeight)
                generateButton(scene,-1,0.3,buttonWidth,buttonHeight)
                
                
                //desni kraj desnog botuna ce bit simetrican s obizrom na y os livom kraju livog -> livi kraj desnog ce pocet di je desni - sirina botuna
                //DESNI
                addButtonHole(frontDeviceFaceShape,1-buttonWidth,0.3,buttonWidth,buttonHeight)
                addButtonFrame(scene,1-buttonWidth,0.3,buttonWidth,buttonHeight)
                generateButton(scene,1-buttonWidth,0.3,buttonWidth,buttonHeight)

                //GORNJI SREDNJI
                addButtonHole(frontDeviceFaceShape,-buttonWidth/2,0.1,buttonWidth,buttonHeight)
                addButtonFrame(scene,-buttonWidth/2,0.1,buttonWidth,buttonHeight)
                generateButton(scene,-buttonWidth/2,0.1,buttonWidth,buttonHeight)

                //DONJI SREDNJI
                addButtonHole(frontDeviceFaceShape,-buttonWidth/2,-2.1,buttonWidth,buttonHeight)
                addButtonFrame(scene,-buttonWidth/2,-2.1,buttonWidth,buttonHeight)
                generateButton(scene,-buttonWidth/2,-2.1,buttonWidth,buttonHeight)
            }

            function generateDeviceScreen(scene)
            {
                let deviceScreenShape=new THREE.Shape();
                deviceScreenShape.moveTo(-1,1);
                deviceScreenShape.lineTo(-1,2);
                deviceScreenShape.lineTo(1,2);
                deviceScreenShape.lineTo(1,1);
                deviceScreenShape.lineTo(-1,1);

                let deviceScreenGeometry = new THREE.PlaneBufferGeometry(2,1);

                let deviceScreenMaterial;
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    // resource URL
                    'textures/logo.png',

                    // onLoad callback
                    function ( texture ) {
                        console.log('Usao u callback');
                        // in this example we create the material when the texture is loaded
                        deviceScreenMaterial= new THREE.MeshBasicMaterial( {
                            map: texture,
                            side:THREE.DoubleSide
                        } );
                        const deviceScreen = new THREE.Mesh(deviceScreenGeometry,deviceScreenMaterial);
                        deviceScreen.rotation.y=2.66-Math.PI;
                        deviceScreen.translateZ(0.001)
                        deviceScreen.translateY(1.5);
                        scene.add(deviceScreen);
                    },

                    // onProgress callback currently not supported
                    undefined,

                    // onError callback
                    function ( err ) {
                        console.error( 'An error happened.' );
                    }
                );
            }

            function generateDeviceTopAntennaRing(scene)//napravi prsten na dnu antene na vrhu uređaja
            {
                let antennaBottomRingExtrudeSettings={
                    //steps: 2,
                    curveSegments:50,
                    steps:30,
                    depth: antennaBottomRingDepth,
                    bevelEnabled: true,
                    bevelSize: 0.03, 
                    bevelThickness: 0.1,
                    bevelSegments:30
                }
                //zbog bevela će rubovi di se spajjau 0 i 2pi ostat crtica/praznina jer se tu primjenuuje, zato vucemo prvi krug skoro do 2PI TAKO DA BEVEL POPUNI TAJ DIO KAD SE NAPRAVI
                let antennaBottomRingShape1=new THREE.Shape();
                //let antennaBottomRingShape2=new THREE.Shape();

                antennaBottomRingShape1.absarc(0,0,antennaRadius,0, 1.99*Math.PI, false)
                //antennaBottomRingShape2.absarc(0,0,antennaRadius,0,2.01*Math.PI,true)

                const antennaBottomRingGeometry1=new THREE.ExtrudeGeometry(antennaBottomRingShape1,antennaBottomRingExtrudeSettings);
                //const antennaBottomRingGeometry2=new THREE.ExtrudeGeometry(antennaBottomRingShape2,antennaBottomRingExtrudeSettings);

                const antennaBottomRing1=new THREE.Mesh(antennaBottomRingGeometry1,antennaBottomRingNutMaterial);
                //const antennaBottomRing2=new THREE.Mesh(antennaBottomRingGeometry2,antennaBottomRingNutMaterial);

                //ROTIRAJ DA BUDU USPRAVNI
                antennaBottomRing1.rotation.x=-Math.PI/2;
                antennaBottomRing1.rotation.z=2.66-Math.PI;
                //antennaBottomRing2.rotation.x=-Math.PI/2;
                //antennaBottomRing2.rotation.z=2.66;

                //TRANSLATIRAJ NA VRH UREDAJA
                antennaBottomRing1.translateZ(height/2+0.1);//nadodjamo bevel thickness jer kad se zarotira donji krug je u ishodistu ali ispod njega ima jos bevel koji je debel toliko pa ga tribamo dignit jos gore za toliko
                antennaBottomRing1.translateX(antennaCenterPosition);
                antennaBottomRing1.translateY((deviceExtrudeDepth+frontDeviceShapeDepth)/2-frontDeviceShapeDepth)//stavi srediste antene na srediste debljine uredaja -> DEBLJINA UREDAJA-> frontDeviceShapeDepth+deviceExtrudeDepth, nase srediste se nalazi di i pocetak extrudanong straznjeg dijela uredaja-> pomicemo srediste do sredine uredaja a to je jos sredina-debljina prednje strane uredaja

                //antennaBottomRing2.translateZ(height/2+0.1);
                //antennaBottomRing2.translateX(antennaCenterPosition);

                scene.add(antennaBottomRing1);
                //scene.add(antennaBottomRing2);



                
            }

            /*function generateDeviceTopAntennaHexagonNut()//napravi maticu iznad prstena na vrhu uređaja
            {

            }

            function generateDeviceTopAntenna()//napravi antenu na vrhu ređaja koja se satoji od 3 dijela(NBROJANA PO REDU OD DOLI PREMA GORE) -> VALJAK, PRSTEN, POLOVICA SFERE(KAPICA NA VRHU, Sphere geomtry, kut theta namisti)
            {

            } */

            function updateButtonMesh()
            {
                buttonExtrudeSettings.steps=world.button.extrusionSteps;
                buttonExtrudeSettings.depth=world.button.extrusionDepth;
                buttonExtrudeSettings.bevelThickness=world.button.extrusionBevelThickness;
                buttonExtrudeSettings.bevelSize=world.button.extrusionBevelSize;
                buttonExtrudeSettings.bevelOffset=world.button.extrusionBevelOffset;
                buttonExtrudeSettings.bevelSegments=world.button.extrusionBevelSegments;
                button.geometry = new THREE.ExtrudeGeometry( buttonShape, buttonExtrudeSettings );
            }
            let deviceFolder=gui.addFolder('device');//ovako se dodaju folderi -> grupiraj parametre po znacenjima raddvoji svitla i objekt 
            deviceFolder.add(world.device, 'width', 1, 20).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'height', 1, 20).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'radius', 0.1, 5).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateX', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateY', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'rotateZ', 0, 2*Math.PI).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'extrusionSteps', 0, 10,1).onChange(updateDeviceMesh)
            deviceFolder.add(world.device, 'extrusionDepth', 0, 10,0.1).onChange(updateDeviceMesh)
            let deviceBottomFolder=gui.addFolder('deviceBottom');
            deviceBottomFolder.add(world.deviceBottom, 'rotateX',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            deviceBottomFolder.add(world.deviceBottom, 'rotateY',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            deviceBottomFolder.add(world.deviceBottom, 'rotateZ',0, 2*Math.PI).onChange(updateDeviceBottomMesh);
            let frontLightFolder=gui.addFolder('frontLight');
            frontLightFolder.add(world.frontLight,'x',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));
            frontLightFolder.add(world.frontLight,'y',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));
            frontLightFolder.add(world.frontLight,'z',-5,5).onChange(()=>frontLight.position.set(world.frontLight.x,world.frontLight.y,world.frontLight.z));;
            let backLightFolder=gui.addFolder('backLight');
            backLightFolder.add(world.backLight,'x',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));
            backLightFolder.add(world.backLight,'y',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));;
            backLightFolder.add(world.backLight,'z',-5,5).onChange(()=>backLight.position.set(world.backLight.x,world.backLight.y,world.backLight.z));;
            let buttonFolder=gui.addFolder('button');
            buttonFolder.add(world.button,'extrusionSteps',0,10,1).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionDepth',0,1,0.01).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelThickness',0,2,0.05).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelSize',0,2,0.05).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelOffset',0,5,0.1).onChange(updateButtonMesh);
            buttonFolder.add(world.button,'extrusionBevelSegments',1,5,1).onChange(updateButtonMesh);

            let height=6,width=4;radius=0.5,deviceMiddleBottomPartDepth=0.1,deviceExtrudeDepth=1,frontDeviceShapeDepth=0.1;

            //extrude postavke za dijelove uredaja -> extrudamo ih prema nazad a ostalo se sve po defualtu extruda prema naprijed
            var backDevicev1 = new THREE.Vector3(0, 0, 0);

            var backDevicev2 = new THREE.Vector3(0, 0, -deviceExtrudeDepth);

            var backDeviceExtrusionPath = new THREE.LineCurve3(backDevicev1, backDevicev2)

            let deviceLeftRightMiddleTopExtrudeSettings = {
                steps: 1,
                bevelEnabled: false,
                extrudePath:backDeviceExtrusionPath
            };

            //on nam se nakon rotacije ide od gore prema dole tako da ne triba definirat smjer extrusiona
            let deviceMiddleBottomExtrudeSettings={
                steps:1,
                depth:deviceMiddleBottomPartDepth,
                bevelEnabled:false
            }

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight,0.01, 1000 );

            const renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            let orbitControls = new THREE.OrbitControls(camera, renderer.domElement);//za mogucnost kretanja oko objekta pomocu misa
            
            let deviceLeftShape=new THREE.Shape();
            let deviceRightShape= new THREE.Shape();
            let deviceMiddleTopShape = new THREE.Shape();
            let deviceMiddleBottomShape= new THREE.Shape();

            //lijevi dio uređaja
            generateDeviceLeftShape();
            const deviceLeftGeometry = new THREE.ExtrudeGeometry( deviceLeftShape, deviceLeftRightMiddleTopExtrudeSettings );
            const deviceMaterial = new THREE.MeshPhongMaterial({
                color: 0x0000ff
            });
            const deviceLeftPart = new THREE.Mesh( deviceLeftGeometry, deviceMaterial );
			deviceLeftPart.rotation.y = 2.66-Math.PI;//VIDI JE LI SE MOZE RISIT SA - JER OVAKO ZAROTIRA CILIO SHAPE ZA 180 SKORO, PROBAT NAC NEKU NEGAITVNU VRIJEDNOST ILI OSTAVI OVAKO ZASAD
            deviceLeftPart.rotation.z=-Math.PI/2;
            scene.add( deviceLeftPart );

            //desni dio uređaja
            generateDeviceRightShape();
            const deviceRightGeometry= new THREE.ExtrudeGeometry( deviceRightShape, deviceLeftRightMiddleTopExtrudeSettings);
            const deviceRightPart= new THREE.Mesh(deviceRightGeometry, deviceMaterial);
            deviceRightPart.rotation.y=2.66-Math.PI;
            deviceRightPart.rotation.z=-Math.PI/2;
            scene.add(deviceRightPart);

            //srednji gornji dio uredaja
            generateDeviceMiddleTopShape();
            const deviceMiddleTopGeometry = new THREE.ExtrudeGeometry( deviceMiddleTopShape, deviceLeftRightMiddleTopExtrudeSettings);
            const deviceMiddleTopPart= new THREE.Mesh(deviceMiddleTopGeometry, deviceMaterial);
            deviceMiddleTopPart.rotation.y=2.66-Math.PI;
            deviceMiddleTopPart.rotation.z=-Math.PI/2;
            scene.add(deviceMiddleTopPart);
            const deviceMaterial2 = new THREE.MeshPhongMaterial({
                color: 0xff0000
            });
            //srednji donji dio uredaja
            generateDeviceMiddleBottomShape();
            const deviceMiddleBottomGeometry= new THREE.ExtrudeGeometry( deviceMiddleBottomShape, deviceMiddleBottomExtrudeSettings);
            const deviceMiddleBottomPart= new THREE.Mesh(deviceMiddleBottomGeometry, deviceMaterial2);
            deviceMiddleBottomPart.rotation.x=-Math.PI/2;
            deviceMiddleBottomPart.rotation.z=2.66;
            deviceMiddleBottomPart.translateY(height/2-deviceMiddleBottomPartDepth)//rotacija se odnosi realtivno u odnosu na gornji vrh shape di smo krenili crtat -> on se nalazi na ovoj udljenosti od sredista
            deviceMiddleBottomPart.translateZ(-height/2)//udaljenost shapea kojeg smo nacrtali i iz kojeg smo extrudali oblik od sredista -> taj shape će nakon rotacije bit zapravo donja strana a njegova udaljenost od sredista po rotiranoj z osi je jednaka polovici visine uredaja
            scene.add(deviceMiddleBottomPart);
 
/*            var singleGeometry = new THREE.BufferGeometry();
            device.updateMatrix(); // as needed
            button.updateMatrix(); // as needed
            singleGeometry=THREE.BufferGeometryUtils.mergeBufferGeometries([device.geometry,button.geometry]);
            var singleMaterial = new THREE.MeshPhongMaterial({color: 0xFF0000});
            var mesh = new THREE.Mesh(singleGeometry, singleMaterial);
            scene.add(mesh); */
            //bijelo svijetlo njjaceg itneziteta, directionall ight oponasa dayligght, paralelene zrake
            //izbusi rupe za botune i ekran kod extrudanja prednjeg dijela uredaja
            
            //BOTUNI
            var buttonWidth = 0.2, buttonHeight = 0.2, buttonFrameOffset=0.01,buttonFrameThickness=0.005, buttonFrameRadius=0.01, buttonBaseDepth=0.01, buttonBevelDepth=0.005;

            let buttonExtrudeSettings = {
                steps: 2,
                depth: buttonBaseDepth,
                bevelEnabled: true,
                bevelThickness: buttonBevelDepth,
                bevelSize: 0.01,
                bevelOffset: 0,
                bevelSegments: 1
            };

            var buttonCircleDepth=0.0165

            let circleExtrudeSettings = {
                steps: 2,
                depth: buttonCircleDepth,
                bevelEnabled: false
            };

            //FRONT FACE DIO
            let frontDeviceFaceShape= new THREE.Shape();
            generateFrontDeviceShape(scene,frontDeviceFaceShape);

            let frontDeviceFaceExtrussionSettings={
                steps:1,
                depth:frontDeviceShapeDepth,
                bevelEnabled:false,
                //extrudePath:frontDeviceExtrusionPath
            }

            let frontDeviceFaceGeometry=new THREE.ExtrudeGeometry( frontDeviceFaceShape, frontDeviceFaceExtrussionSettings );
            //frontDeviceFaceGeometry.scale(1,1,-1);//obrni smjer extrudanja
            let frontFaceMaterial= new THREE.MeshPhongMaterial({
                color: 0xff0000
            });
            const frontFace= new THREE.Mesh(frontDeviceFaceGeometry, frontFaceMaterial)
            frontFace.rotation.y=2.66-Math.PI;
            //frontFace.rotation.z=-Math.PI/2//ROTIRA GA ZA 90 OKO Z NEZ ZAS, JE LI TO DEFAULTNA RADNJA EXTRUDEPATH OPCIJE? https://stackoverflow.com/questions/25626171/threejs-extrudegeometry-depth-gives-different-result-than-extrudepath
            scene.add(frontFace);

            generateDeviceScreen(scene);


            //generiraj antenu na vrhu po dijelovima
            //parametri za djelove antene
            let antennaRadius=0.2;
            let antennaCenterPosition=-1;//pozicija sredisnjeg dijela antene na vrhu uredaja
            let antennaBottomRingDepth=0.1;//prsten na dnu
            let antennaHexagonNutDepth=1;//sesterokutasta matica
            let antennaCilinderHeight=3;//visina valjka ispod kugline kapice
            let antennaBottomRingNutMaterial=new THREE.MeshPhongMaterial({
                    color:0xffc107
            })
            generateDeviceTopAntennaRing(scene);


            const frontLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            frontLight.position.set(0,1,1);
            scene.add(frontLight);
            camera.position.z = 5;

            const backLight= new THREE.DirectionalLight(0xffffff,1)//dodaj svjetlo da dobijemo efekte sjena, potrebno kad koristimo meshphong material -> on reagira sa sjenom
            backLight.position.set(0,-1,-1);
            scene.add(backLight);
            console.log(orbitControls.target);

            function onWindowResize() {//responsive desgin na resize prozora, prati promjenu velicine prozora tako da mozemo testirat na manjin ekranima, inace se nec minja ovi aspekt i nas uredaj stoji fiksno ko na velikon ekranu pa ce smannivanjen ekrana skroz nestat iz vidiljvig podrucja, samo crnilo

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

            }

            window.addEventListener('resize',onWindowResize);


            function animate() {
                requestAnimationFrame( animate );//This will create a loop that causes the renderer to draw the scene every time the screen is refreshed

                renderer.render( scene,camera);
            }
            animate();
		</script>
	</body>
</html>